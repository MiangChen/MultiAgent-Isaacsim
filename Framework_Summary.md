# æ¶æ„æ€»ç»“

## ğŸ“ ä¸‰å±‚æ¶æ„è®¾è®¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Application Layer                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚  â”‚  Skill System    â”‚  â”‚  ROS Bridge      â”‚                â”‚
â”‚  â”‚  - SkillManager  â”‚  â”‚  - cmd_vel       â”‚                â”‚
â”‚  â”‚  - @register     â”‚  â”‚  - action server â”‚                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Simulation Layer                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚  â”‚  World           â”‚  â”‚  Actor System    â”‚                â”‚
â”‚  â”‚  - spawn_actor() â”‚  â”‚  - RobotActor    â”‚                â”‚
â”‚  â”‚  - Blueprint     â”‚  â”‚  - StaticActor   â”‚                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Isaac Sim                               â”‚
â”‚              Physics Engine + Rendering                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ¯ æ ¸å¿ƒè®¾è®¡åŸåˆ™

1. **åˆ†å±‚è¾¹ç•Œæ¸…æ™°** - Application å±‚ä¸ç›´æ¥è°ƒç”¨ Isaac Sim API
2. **CARLA é£æ ¼ API** - ç»Ÿä¸€çš„ spawn_actor, apply_control æ¥å£
3. **çŠ¶æ€ä¸å‘½ä»¤åˆ†ç¦»** - åŒºåˆ†å®é™…çŠ¶æ€å’Œæ§åˆ¶å‘½ä»¤
4. **åŒæ­¥æ§åˆ¶** - MPC ç›´æ¥è®¾ç½®é€Ÿåº¦ï¼Œé¿å… ROS å»¶è¿Ÿ
5. **ç±»å‹å®‰å…¨** - ä½¿ç”¨ Blueprint, Transform, Control ç­‰æ•°æ®ç±»

---

## âœ… æ ¸å¿ƒç»„ä»¶

### 1. World ç±»ï¼ˆCARLA é£æ ¼ï¼‰

**ç»Ÿä¸€çš„ Actor åˆ›å»ºæ¥å£ï¼š**
```python
# åˆ›å»ºæœºå™¨äºº
blueprint_library = world.get_blueprint_library()
robot_bp = blueprint_library.find('robot.jetbot')
robot_bp.set_attribute('namespace', 'robot_0')
robot_actor = world.spawn_actor(robot_bp, transform)  # è¿”å› RobotActor

# åˆ›å»ºé™æ€ç‰©ä½“
car_bp = blueprint_library.find('static.prop.car')
car_bp.set_attribute('name', 'car0')
car_bp.set_attribute('scale', [2, 5, 1.0])
car_actor = world.spawn_actor(car_bp, transform)  # è¿”å› StaticActor
```

**å…³é”®æ–¹æ³•ï¼š**
- `spawn_actor(blueprint, transform)` - ç»Ÿä¸€åˆ›å»ºæ¥å£
- `get_blueprint_library()` - è·å– Blueprint åº“
- `load_actors_from_config(path)` - ä»é…ç½®æ–‡ä»¶åŠ è½½
- `get_actors()` - è·å–æ‰€æœ‰ Actor
- `tick()` - ä»¿çœŸæ­¥è¿›

**å†…éƒ¨å®ç°ï¼š**
- ä½¿ç”¨ `blueprint.has_tag('static')` åˆ¤æ–­ç±»å‹
- é™æ€ç‰©ä½“ â†’ `_spawn_static_prop()` â†’ è¿”å› `StaticActor`
- æœºå™¨äºº â†’ `_spawn_robot()` â†’ è¿”å› `RobotActor`

---

### 2. Actor ç³»ç»Ÿ

**Actor åŸºç±»ï¼š**
```python
class Actor:
    def get_id(self) -> int
    def get_type_id(self) -> str
    def get_transform(self) -> Transform
    def set_transform(self, transform: Transform)
    def get_location(self) -> Location
    def get_velocity(self) -> Vector3D
    def destroy()
```

**RobotActorï¼ˆåŠ¨æ€ Actorï¼‰ï¼š**
```python
class RobotActor(Actor):
    def __init__(self, robot, world):
        self.robot = robot  # å¼•ç”¨ Robot å®ä¾‹
        robot.actor = self  # åŒå‘å¼•ç”¨
    
    def get_type_id(self) -> str:
        return f"robot.{self.robot.cfg_robot.type}"
```

**StaticActorï¼ˆé™æ€ Actorï¼‰ï¼š**
```python
class StaticActor(Actor):
    def __init__(self, prim_path, world, semantic_label):
        self._prim_path = prim_path
        self._semantic_label = semantic_label
    
    def get_type_id(self) -> str:
        return f"static.prop.{self._semantic_label}"
```

**è®¾è®¡ä¼˜ç‚¹ï¼š**
- ç»Ÿä¸€çš„æ¥å£ï¼Œæ— è®ºæœºå™¨äººè¿˜æ˜¯é™æ€ç‰©ä½“
- åŒå‘å¼•ç”¨ï¼š`robot.actor` å’Œ `actor.robot`
- è‡ªåŠ¨æ³¨å†Œåˆ° World çš„ Actor åˆ—è¡¨

---

### 3. Robot ç±» - çŠ¶æ€ä¸å‘½ä»¤åˆ†ç¦»ï¼ˆCARLA é£æ ¼ï¼‰

**æ ¸å¿ƒæ¦‚å¿µï¼š**
- **çŠ¶æ€å˜é‡**ï¼ˆStateï¼‰ï¼šä» Isaac Sim è¯»å–çš„å®é™…å€¼
- **å‘½ä»¤å˜é‡**ï¼ˆCommandï¼‰ï¼šæ§åˆ¶å™¨è®¾ç½®çš„ç›®æ ‡å€¼

**çŠ¶æ€å˜é‡ï¼ˆç§æœ‰ï¼Œåªè¯»ï¼‰ï¼š**

```python
# åœ¨ on_physics_step ä¸­ä» Isaac Sim æ›´æ–°
self._position = torch.tensor([0.0, 0.0, 0.0])
self._quat = torch.tensor([0.0, 0.0, 0.0, 1.0])
self._linear_velocity = torch.tensor([0.0, 0.0, 0.0])  # å®é™…çº¿é€Ÿåº¦
self._angular_velocity = torch.tensor([0.0, 0.0, 0.0])  # å®é™…è§’é€Ÿåº¦


# å…¬å…±æ¥å£ï¼ˆCARLA é£æ ¼ï¼‰
def get_velocity(self) -> torch.Tensor


    def get_angular_velocity(self) -> torch.Tensor

    def get_world_pose() -> Tuple[torch.Tensor, torch.Tensor]
```

**å‘½ä»¤å˜é‡ï¼ˆå…¬å…±ï¼Œå¯å†™ï¼‰ï¼š**

```python
# ç”±æ§åˆ¶å™¨è®¾ç½®ï¼Œåœ¨ controller_simplified ä¸­åº”ç”¨åˆ° Isaac Sim
self.target_linear_velocity = torch.tensor([0.0, 0.0, 0.0])  # ç›®æ ‡çº¿é€Ÿåº¦
self.target_angular_velocity = torch.tensor([0.0, 0.0, 0.0])  # ç›®æ ‡è§’é€Ÿåº¦


# å…¬å…±æ¥å£
def set_target_velocity(linear_velocity, angular_velocity=None)


    def apply_control(control: RobotControl)
```

**å…³é”®ï¼šé¿å…è¦†ç›–é—®é¢˜**

```python
def publish_robot_state(self):
    """åœ¨ on_physics_step ä¸­è°ƒç”¨ï¼Œæ›´æ–°çŠ¶æ€"""
    pos, quat = self._body.get_world_pose()
    vel, ang_vel = self._body.get_world_vel()

    # åªæ›´æ–°çŠ¶æ€å˜é‡
    self._position = pos
    self._quat = quat
    self._linear_velocity = vel
    self._angular_velocity = ang_vel

    # ä¸æ›´æ–° target_linear_velocity/target_angular_velocityï¼
    # å®ƒä»¬æ˜¯å‘½ä»¤ï¼Œç”± MPC/æ§åˆ¶å™¨è®¾ç½®
```

---

***

### 6. Blueprint ç±»

Blueprint ç³»ç»Ÿæä¾›äº†ç±»ä¼¼ CARLA çš„ Actor åˆ›å»ºæœºåˆ¶ï¼Œé€šè¿‡ç±»å‹æ ‡è¯†ç¬¦å’Œå±æ€§é…ç½®æ¥åˆ›å»ºä¸åŒç±»å‹çš„å¯¹è±¡ã€‚

#### 6.1 Blueprint åº“

**è·å– Blueprint åº“ï¼š**
```python
blueprint_library = world.get_blueprint_library()

# æŸ¥æ‰¾ç‰¹å®šç±»å‹çš„ Blueprint
robot_bp = blueprint_library.find('robot.jetbot')
car_bp = blueprint_library.find('static.prop.car')

# è·å–æ‰€æœ‰å¯ç”¨çš„ Blueprint
all_blueprints = blueprint_library.filter('*')  # è¿”å›æ‰€æœ‰
robot_blueprints = blueprint_library.filter('robot.*')  # åªè¿”å›æœºå™¨äºº
```

#### 6.2 é¢„æ³¨å†Œçš„ç±»å‹

**æœºå™¨äººç±»å‹ï¼ˆrobot.*ï¼‰ï¼š**
```python
- robot.jetbot      # Jetbot è½®å¼æœºå™¨äºº
- robot.h1          # Unitree H1 äººå½¢æœºå™¨äºº
- robot.g1          # Unitree G1 äººå½¢æœºå™¨äºº
- robot.cf2x        # Crazyflie 2.x å››æ—‹ç¿¼æ— äººæœº
- robot.autel       # Autel æ— äººæœº
- robot.target      # ç›®æ ‡æœºå™¨äººï¼ˆç”¨äºè·Ÿè¸ªä»»åŠ¡ï¼‰
```

**é™æ€ç‰©ä½“ç±»å‹ï¼ˆstatic.prop.*ï¼‰ï¼š**
```python
- static.prop.box   # ç«‹æ–¹ä½“éšœç¢ç‰©
- static.prop.car   # æ±½è½¦æ¨¡å‹ï¼ˆé™æ€ï¼‰
```

#### 6.3 Blueprint å±æ€§é…ç½®

**æœºå™¨äºº Blueprint å±æ€§ï¼š**
```python
robot_bp = blueprint_library.find('robot.jetbot')

# è®¾ç½®å‘½åç©ºé—´ï¼ˆå¿…éœ€ï¼‰
robot_bp.set_attribute('namespace', 'robot_0')

# è®¾ç½®åˆå§‹ä½ç½®ï¼ˆå¯é€‰ï¼Œä¹Ÿå¯ä»¥åœ¨ spawn_actor æ—¶æŒ‡å®šï¼‰
robot_bp.set_attribute('position', [0.0, 0.0, 0.5])
robot_bp.set_attribute('orientation', [0.0, 0.0, 0.0, 1.0])  # å››å…ƒæ•°

# è®¾ç½®ä¼ æ„Ÿå™¨é…ç½®ï¼ˆå¯é€‰ï¼‰
robot_bp.set_attribute('enable_lidar', True)
robot_bp.set_attribute('enable_camera', True)
```

**é™æ€ç‰©ä½“ Blueprint å±æ€§ï¼š**
```python
car_bp = blueprint_library.find('static.prop.car')

# è®¾ç½®åç§°ï¼ˆå¿…éœ€ï¼‰
car_bp.set_attribute('name', 'car0')

# è®¾ç½®ç¼©æ”¾ï¼ˆå¯é€‰ï¼Œé»˜è®¤ [1.0, 1.0, 1.0]ï¼‰
car_bp.set_attribute('scale', [2.0, 5.0, 1.0])  # [x, y, z]

# è®¾ç½®è¯­ä¹‰æ ‡ç­¾ï¼ˆå¯é€‰ï¼Œç”¨äºä¼ æ„Ÿå™¨è¯†åˆ«ï¼‰
car_bp.set_attribute('semantic_label', 'car')

# è®¾ç½®é¢œè‰²ï¼ˆå¯é€‰ï¼‰
car_bp.set_attribute('color', [1.0, 0.0, 0.0])  # RGB
```

#### 6.4 ä½¿ç”¨ Tags åˆ¤æ–­ç±»å‹

Blueprint ä½¿ç”¨ tags ç³»ç»Ÿæ¥æ ‡è¯†å¯¹è±¡ç±»å‹ï¼Œè¿™æ¯”ä½¿ç”¨ç±»åæˆ–å…¶ä»–éšå¼åˆ¤æ–­æ›´çµæ´»ã€‚

**å†…éƒ¨å®ç°ï¼š**
```python
class ActorBlueprint:
    def __init__(self, id: str, tags: List[str]):
        self.id = id  # ä¾‹å¦‚ 'robot.jetbot'
        self.tags = tags  # ä¾‹å¦‚ ['robot', 'wheeled']
        self._attributes = {}
    
    def has_tag(self, tag: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦åŒ…å«æŒ‡å®š tag"""
        return tag in self.tags
    
    def set_attribute(self, key: str, value):
        """è®¾ç½®å±æ€§"""
        self._attributes[key] = value
    
    def get_attribute(self, key: str):
        """è·å–å±æ€§"""
        return self._attributes.get(key)
```

**World ä¸­çš„ç±»å‹åˆ¤æ–­ï¼š**
```python
def spawn_actor(self, blueprint, transform=None):
    """æ ¹æ® Blueprint çš„ tags åˆ›å»ºå¯¹åº”çš„ Actor"""
    
    # ä½¿ç”¨ tags åˆ¤æ–­ç±»å‹ï¼ˆæ¨èæ–¹å¼ï¼‰
    if blueprint.has_tag('static'):
        return self._spawn_static_prop(blueprint, transform)
    
    if blueprint.has_tag('robot'):
        return self._spawn_robot(blueprint, transform)
    
    # æœªæ¥å¯æ‰©å±•
    if blueprint.has_tag('vehicle'):
        return self._spawn_vehicle(blueprint, transform)
    
    if blueprint.has_tag('sensor'):
        return self._spawn_sensor(blueprint, transform)
    
    # Fallbackï¼šé»˜è®¤ä½œä¸ºé™æ€ç‰©ä½“
    return self._spawn_static_prop(blueprint, transform)
```

#### 6.5 å®Œæ•´ä½¿ç”¨ç¤ºä¾‹

**åˆ›å»ºæœºå™¨äººï¼š**
```python
# 1. è·å– Blueprint
blueprint_library = world.get_blueprint_library()
robot_bp = blueprint_library.find('robot.jetbot')

# 2. é…ç½®å±æ€§
robot_bp.set_attribute('namespace', 'robot_0')

# 3. åˆ›å»º Transform
transform = Transform(
    location=Location(x=0.0, y=0.0, z=0.5),
    rotation=Rotation(roll=0.0, pitch=0.0, yaw=0.0)
)

# 4. ç”Ÿæˆ Actor
robot_actor = world.spawn_actor(robot_bp, transform)

# 5. è·å– Robot å¯¹è±¡ï¼ˆå¦‚æœéœ€è¦ï¼‰
robot = robot_actor.robot
```

**åˆ›å»ºé™æ€ç‰©ä½“ï¼š**
```python
# 1. è·å– Blueprint
car_bp = blueprint_library.find('static.prop.car')

# 2. é…ç½®å±æ€§
car_bp.set_attribute('name', 'car0')
car_bp.set_attribute('scale', [2.0, 5.0, 1.0])
car_bp.set_attribute('semantic_label', 'car')

# 3. åˆ›å»º Transform
transform = Transform(location=Location(x=10.0, y=5.0, z=0.0))

# 4. ç”Ÿæˆ Actor
car_actor = world.spawn_actor(car_bp, transform)

# 5. è·å– Actor ä¿¡æ¯
print(f"Actor ID: {car_actor.get_id()}")
print(f"Actor Type: {car_actor.get_type_id()}")  # è¾“å‡º: static.prop.car
```

#### 6.6 è®¾è®¡ä¼˜ç‚¹

**1. çµæ´»çš„ç±»å‹ç³»ç»Ÿï¼š**
- ä¸€ä¸ª Blueprint å¯ä»¥æœ‰å¤šä¸ª tagsï¼ˆä¾‹å¦‚ï¼š`['robot', 'wheeled', 'ground']`ï¼‰
- å¯ä»¥æ ¹æ®ä¸åŒçš„ tag è¿›è¡Œè¿‡æ»¤å’Œåˆ¤æ–­
- æ˜“äºæ·»åŠ æ–°çš„ç±»å‹åˆ†ç±»

**2. æ˜“äºæ‰©å±•ï¼š**
```python
# æ·»åŠ æ–°ç±»å‹åªéœ€æ³¨å†Œæ–°çš„ Blueprint
blueprint_library.register(
    ActorBlueprint(
        id='vehicle.sedan',
        tags=['vehicle', 'wheeled', 'dynamic']
    )
)

# World ä¸­æ·»åŠ å¯¹åº”çš„ç”Ÿæˆæ–¹æ³•
def spawn_actor(self, blueprint, transform=None):
    if blueprint.has_tag('vehicle'):
        return self._spawn_vehicle(blueprint, transform)
    # ...
```

**3. æ˜¾å¼ç±»å‹åˆ¤æ–­ï¼š**
- ä¸ä¾èµ– `robot_class is None` è¿™ç§éšå¼åˆ¤æ–­
- ä»£ç æ„å›¾æ¸…æ™°ï¼Œæ˜“äºç†è§£å’Œç»´æŠ¤
- é¿å…äº†ç±»å‹åˆ¤æ–­çš„æ­§ä¹‰

**4. å±æ€§ç³»ç»Ÿçµæ´»ï¼š**
- æ¯ä¸ª Blueprint å¯ä»¥æœ‰ä¸åŒçš„å±æ€§
- å±æ€§åœ¨åˆ›å»ºæ—¶é…ç½®ï¼Œä¸éœ€è¦ä¿®æ”¹ç±»å®šä¹‰
- æ”¯æŒè¿è¡Œæ—¶åŠ¨æ€é…ç½®

#### 6.7 ä¸ CARLA çš„å¯¹æ¯”

| ç‰¹æ€§ | CARLA | æœ¬ç³»ç»Ÿ |
|------|-------|--------|
| Blueprint åº“ | `world.get_blueprint_library()` | âœ… ç›¸åŒ |
| ç±»å‹æ ‡è¯†ç¬¦ | `vehicle.tesla.model3` | âœ… ç±»ä¼¼ï¼ˆ`robot.jetbot`ï¼‰ |
| Tags ç³»ç»Ÿ | âœ… æ”¯æŒ | âœ… æ”¯æŒ |
| å±æ€§é…ç½® | `bp.set_attribute()` | âœ… ç›¸åŒ |
| ç»Ÿä¸€åˆ›å»ºæ¥å£ | `world.spawn_actor()` | âœ… ç›¸åŒ |
| è¿”å›ç±»å‹ | Actor å¯¹è±¡ | âœ… Actor å¯¹è±¡ |

---

### 7. ROS Robot Manager ç±»

ROS Robot Manager è´Ÿè´£ç®¡ç†å•ä¸ªæœºå™¨äººçš„æ‰€æœ‰ ROS åŸºç¡€è®¾æ–½ï¼Œå®ç°äº†ä»¿çœŸå±‚ä¸ ROS å±‚çš„å®Œå…¨è§£è€¦ã€‚æ¯ä¸ªæœºå™¨äººéƒ½æœ‰ç‹¬ç«‹çš„ ROS Manager å®ä¾‹ï¼Œç®¡ç†å…¶ ROS èŠ‚ç‚¹ã€è¯é¢˜ã€æœåŠ¡å’Œ Actionã€‚

#### 7.1 æ¶æ„æ¦‚è§ˆ

**ROS Robot Manager çš„èŒè´£ï¼š**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              RobotRosManager (per robot)                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  ROS Nodes                                            â”‚  â”‚
â”‚  â”‚  - NodeRobot (ä¸»èŠ‚ç‚¹)                                 â”‚  â”‚
â”‚  â”‚  - NodePlannerOmpl (è·¯å¾„è§„åˆ’)                         â”‚  â”‚
â”‚  â”‚  - NodeTrajectoryGenerator (è½¨è¿¹ç”Ÿæˆ)                 â”‚  â”‚
â”‚  â”‚  - NodeMpcController (MPC æ§åˆ¶å™¨)                     â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  ROS Communication                                    â”‚  â”‚
â”‚  â”‚  - Publishers: /robot_0/odom                          â”‚  â”‚
â”‚  â”‚  - Subscribers: /robot_0/cmd_vel, /sim_clock         â”‚  â”‚
â”‚  â”‚  - Action Servers: /robot_0/skill_execution          â”‚  â”‚
â”‚  â”‚  - Action Clients: /robot_0/compute_path_to_pose     â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Threading & Execution                                â”‚  â”‚
â”‚  â”‚  - MultiThreadedExecutor                              â”‚  â”‚
â”‚  â”‚  - ROS Thread (ç‹¬ç«‹çº¿ç¨‹è¿è¡Œ)                          â”‚  â”‚
â”‚  â”‚  - Stop Event (ä¼˜é›…å…³é—­)                              â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 7.2 æ ¸å¿ƒç»„ä»¶

**RobotRosManager ç±»ï¼š**
```python
class RobotRosManager:
    """ç®¡ç†å•ä¸ªæœºå™¨äººçš„æ‰€æœ‰ ROS åŸºç¡€è®¾æ–½"""
    
    def __init__(self, robot, namespace: str, topics: dict):
        """
        åˆå§‹åŒ– ROS Manager
        
        Args:
            robot: Robot å®ä¾‹ï¼ˆä»¿çœŸå±‚ï¼‰
            namespace: æœºå™¨äººå‘½åç©ºé—´ï¼ˆä¾‹å¦‚ 'robot_0'ï¼‰
            topics: ROS è¯é¢˜é…ç½®å­—å…¸
        """
        self.robot = robot
        self.namespace = namespace
        self.topics = topics
        
        # ROS èŠ‚ç‚¹
        self.node = None                          # ä¸»èŠ‚ç‚¹
        self.node_planner_ompl = None             # OMPL è·¯å¾„è§„åˆ’å™¨
        self.node_trajectory_generator = None     # è½¨è¿¹ç”Ÿæˆå™¨
        self.node_controller_mpc = None           # MPC æ§åˆ¶å™¨
        
        # Action å®¢æˆ·ç«¯
        self.action_client_path_planner = None
        
        # æ‰§è¡Œå™¨å’Œçº¿ç¨‹
        self.executor = None
        self.ros_thread = None
        self.stop_event = threading.Event()
```

#### 7.3 åˆå§‹åŒ–æµç¨‹

**å®Œæ•´çš„åˆå§‹åŒ–è¿‡ç¨‹ï¼š**
```python
# 1. åˆ›å»º ROS Manager
ros_manager = RobotRosManager(
    robot=robot,
    namespace='robot_0',
    topics={
        'odom': '/robot_0/odom',
        'cmd_vel': '/robot_0/cmd_vel',
    }
)

# 2. å†…éƒ¨è‡ªåŠ¨åˆå§‹åŒ–ï¼ˆåœ¨ __init__ ä¸­ï¼‰
# - _init_ros_nodes()        # åˆ›å»ºæ‰€æœ‰ ROS èŠ‚ç‚¹
# - _init_action_clients()   # åˆ›å»º Action å®¢æˆ·ç«¯
# - _init_executor()         # åˆ›å»ºæ‰§è¡Œå™¨å¹¶æ·»åŠ èŠ‚ç‚¹

# 3. è®¾ç½®åˆ° Robot
robot.set_ros_manager(ros_manager)

# 4. å¯åŠ¨ ROS çº¿ç¨‹
ros_manager.start()
```

**å†…éƒ¨åˆå§‹åŒ–æ–¹æ³•ï¼š**
```python
def _init_ros_nodes(self):
    """åˆå§‹åŒ–æ‰€æœ‰ ROS èŠ‚ç‚¹"""
    # ä¸»èŠ‚ç‚¹ï¼ˆå¤„ç† odom, cmd_vel, skill_executionï¼‰
    self.node = NodeRobot(
        namespace=self.namespace,
        topics=self.topics
    )
    self.node.set_robot_instance(self.robot)
    
    # å¯¼èˆªèŠ‚ç‚¹
    self.node_planner_ompl = NodePlannerOmpl(
        namespace=self.namespace
    )
    self.node_trajectory_generator = NodeTrajectoryGenerator(
        namespace=self.namespace
    )
    self.node_controller_mpc = NodeMpcController(
        namespace=self.namespace,
        robot=self.robot  # ä¼ é€’ robot å¼•ç”¨ç”¨äºç›´æ¥æ§åˆ¶
    )

def _init_action_clients(self):
    """åˆå§‹åŒ– Action å®¢æˆ·ç«¯"""
    self.action_client_path_planner = ActionClient(
        self.node,
        ComputePathToPose,
        'action_compute_path_to_pose'
    )

def _init_executor(self):
    """åˆå§‹åŒ–æ‰§è¡Œå™¨å¹¶æ·»åŠ æ‰€æœ‰èŠ‚ç‚¹"""
    self.executor = MultiThreadedExecutor()
    self.executor.add_node(self.node)
    self.executor.add_node(self.node_planner_ompl)
    self.executor.add_node(self.node_trajectory_generator)
    self.executor.add_node(self.node_controller_mpc)
```

#### 7.4 NodeRobot - ä¸» ROS èŠ‚ç‚¹

NodeRobot æ˜¯æ¯ä¸ªæœºå™¨äººçš„ä¸»è¦ ROS èŠ‚ç‚¹ï¼Œè´Ÿè´£åŸºæœ¬çš„ ROS é€šä¿¡ã€‚

**Publishersï¼ˆå‘å¸ƒè€…ï¼‰ï¼š**
```python
# Odometryï¼ˆé‡Œç¨‹è®¡ï¼‰
/robot_0/odom  # nav_msgs/Odometry
# å‘å¸ƒé¢‘ç‡ï¼šæ¯ä¸ª physics stepï¼ˆé€šå¸¸ 60Hzï¼‰
# å†…å®¹ï¼šä½ç½®ã€å§¿æ€ã€çº¿é€Ÿåº¦ã€è§’é€Ÿåº¦
```

**Subscribersï¼ˆè®¢é˜…è€…ï¼‰ï¼š**
```python
# cmd_velï¼ˆé€Ÿåº¦å‘½ä»¤ï¼‰
/robot_0/cmd_vel  # geometry_msgs/Twist
# ç”¨é€”ï¼šå¤–éƒ¨æ§åˆ¶ï¼ˆé¥æ§ã€é”®ç›˜ã€joystickï¼‰
# å›è°ƒï¼šè‡ªåŠ¨è½¬æ¢ä¸º RobotControl å¹¶åº”ç”¨

# Simulation Clockï¼ˆä»¿çœŸæ—¶é’Ÿï¼‰
/isaacsim_simulation_clock  # rosgraph_msgs/Clock
# ç”¨é€”ï¼šåŒæ­¥ä»¿çœŸæ—¶é—´
# è§¦å‘ï¼šMPC æ§åˆ¶å™¨çš„ control_loop
```

**Action Serversï¼ˆåŠ¨ä½œæœåŠ¡å™¨ï¼‰ï¼š**
```python
# Skill Executionï¼ˆæŠ€èƒ½æ‰§è¡Œï¼‰
/robot_0/skill_execution  # plan_msgs/SkillExecution
# ç”¨é€”ï¼šæ‰§è¡Œé«˜çº§æŠ€èƒ½ï¼ˆnavigate_to, follow_path ç­‰ï¼‰
# åé¦ˆï¼šå®æ—¶çŠ¶æ€å’Œè¿›åº¦
```

**cmd_vel å›è°ƒç¤ºä¾‹ï¼š**
```python
def callback_cmd_vel(self, msg: Twist):
    """
    æ¥æ”¶å¤–éƒ¨é€Ÿåº¦å‘½ä»¤å¹¶åº”ç”¨åˆ°æœºå™¨äºº
    
    æ”¯æŒçš„æ§åˆ¶æ–¹å¼ï¼š
    - ros2 topic pub
    - teleop_twist_keyboard
    - joystick
    """
    from simulation.control import RobotControl
    
    control = RobotControl()
    control.linear_velocity = [msg.linear.x, msg.linear.y, msg.linear.z]
    control.angular_velocity = [msg.angular.x, msg.angular.y, msg.angular.z]
    
    if self.robot_instance:
        self.robot_instance.apply_control(control)
```

#### 7.5 å¯¼èˆªèŠ‚ç‚¹

**NodePlannerOmplï¼ˆè·¯å¾„è§„åˆ’å™¨ï¼‰ï¼š**
```python
# Action Server
/robot_0/action_compute_path_to_pose  # nav2_msgs/ComputePathToPose

# åŠŸèƒ½ï¼š
# - ä½¿ç”¨ OMPL ç®—æ³•è®¡ç®—æ— ç¢°æ’è·¯å¾„
# - æ”¯æŒå¤šç§è§„åˆ’ç®—æ³•ï¼ˆRRT, RRT*, PRM ç­‰ï¼‰
# - è€ƒè™‘éšœç¢ç‰©å’Œæœºå™¨äººå°ºå¯¸
# - è¿”å›è·¯å¾„ç‚¹åˆ—è¡¨
```

**NodeTrajectoryGeneratorï¼ˆè½¨è¿¹ç”Ÿæˆå™¨ï¼‰ï¼š**
```python
# Action Server
/robot_0/action_generate_trajectory  # plan_msgs/GenerateTrajectory

# åŠŸèƒ½ï¼š
# - å°†è·¯å¾„è½¬æ¢ä¸ºå¸¦æ—¶é—´æˆ³çš„è½¨è¿¹
# - è€ƒè™‘é€Ÿåº¦å’ŒåŠ é€Ÿåº¦é™åˆ¶
# - ç”Ÿæˆå¹³æ»‘çš„é€Ÿåº¦æ›²çº¿
# - ç”¨äº MPC è·Ÿè¸ª
```

**NodeMpcControllerï¼ˆMPC æ§åˆ¶å™¨ï¼‰ï¼š**
```python
# Subscriber
/isaacsim_simulation_clock  # rosgraph_msgs/Clock

# åŠŸèƒ½ï¼š
# - è®¢é˜…ä»¿çœŸæ—¶é’Ÿï¼Œè‡ªåŠ¨è§¦å‘æ§åˆ¶å¾ªç¯
# - ä½¿ç”¨ MPC ç®—æ³•è®¡ç®—æœ€ä¼˜æ§åˆ¶
# - ç›´æ¥è®¾ç½® robot.target_velocityï¼ˆåŒæ­¥ï¼Œæ— å»¶è¿Ÿï¼‰
# - å‘å¸ƒ cmd_vel ç”¨äºç›‘æ§å’Œè°ƒè¯•

# å…³é”®ç‰¹æ€§ï¼š
# âœ… è‡ªåŠ¨è§¦å‘ï¼ˆé€šè¿‡ clock_callbackï¼‰
# âœ… åŒæ­¥æ§åˆ¶ï¼ˆç›´æ¥è®¾ç½®é€Ÿåº¦ï¼‰
# âœ… å®Œå…¨è§£è€¦ï¼ˆRobot å±‚ä¸çŸ¥é“ MPC çš„å­˜åœ¨ï¼‰
```

#### 7.6 çº¿ç¨‹ç®¡ç†

**ç‹¬ç«‹çš„ ROS çº¿ç¨‹ï¼š**
```python
def start(self):
    """å¯åŠ¨ ROS çº¿ç¨‹"""
    if self.ros_thread is None or not self.ros_thread.is_alive():
        self.stop_event.clear()
        self.ros_thread = threading.Thread(
            target=self._spin_ros,
            daemon=True,
            name=f"ROS_{self.namespace}"
        )
        self.ros_thread.start()

def _spin_ros(self):
    """ROS æ—‹è½¬å¾ªç¯ï¼ˆåœ¨ç‹¬ç«‹çº¿ç¨‹ä¸­è¿è¡Œï¼‰"""
    try:
        while not self.stop_event.is_set():
            self.executor.spin_once(timeout_sec=0.05)
    except Exception as e:
        logger.error(f"ROS thread error: {e}")

def stop(self):
    """åœæ­¢ ROS çº¿ç¨‹å¹¶æ¸…ç†"""
    if self.ros_thread and self.ros_thread.is_alive():
        self.stop_event.set()
        self.ros_thread.join(timeout=2.0)
```

**çº¿ç¨‹å®‰å…¨è®¾è®¡ï¼š**
- ROS é€šä¿¡åœ¨ç‹¬ç«‹çº¿ç¨‹ä¸­è¿è¡Œ
- ä½¿ç”¨ `stop_event` å®ç°ä¼˜é›…å…³é—­
- MultiThreadedExecutor å¤„ç†å¤šä¸ªèŠ‚ç‚¹
- é¿å…é˜»å¡ä¸»ä»¿çœŸå¾ªç¯

#### 7.7 å®Œæ•´ä½¿ç”¨ç¤ºä¾‹

**å•æœºå™¨äººè®¾ç½®ï¼š**
```python
import rclpy
from containers import get_container
from ros.ros_manager_robot import RobotRosManager

# 1. åˆå§‹åŒ– ROS
rclpy.init(args=None)

# 2. åˆ›å»ºæœºå™¨äºº
container = get_container()
world = container.world_configured()
robot_actors = world.load_actors_from_config("config/robot_cfg.yaml")
robot = robot_actors[0].robot

# 3. é…ç½® ROS è¯é¢˜
topics = {
    'odom': f'/{robot.namespace}/odom',
    'cmd_vel': f'/{robot.namespace}/cmd_vel',
}

# 4. åˆ›å»ºå¹¶å¯åŠ¨ ROS Manager
ros_manager = RobotRosManager(
    robot=robot,
    namespace=robot.namespace,
    topics=topics
)
robot.set_ros_manager(ros_manager)
ros_manager.start()

# 5. åˆå§‹åŒ–æœºå™¨äºº
world.reset()
world.initialize_robots()

# 6. æ·»åŠ ç‰©ç†å›è°ƒ
world.get_isaac_world().add_physics_callback(
    "physics_step_robot_0",
    robot.on_physics_step
)

# 7. ä¸»å¾ªç¯
while simulation_app.is_running():
    world.tick()

# 8. æ¸…ç†
ros_manager.stop()
rclpy.shutdown()
```

**å¤šæœºå™¨äººè®¾ç½®ï¼š**
```python
# åŠ è½½å¤šä¸ªæœºå™¨äºº
robot_actors = world.load_actors_from_config("config/robot_swarm_cfg.yaml")
robots = [actor.robot for actor in robot_actors]

# ä¸ºæ¯ä¸ªæœºå™¨äººåˆ›å»º ROS Manager
ros_managers = []
for i, robot in enumerate(robots):
    topics = {
        'odom': f'/{robot.namespace}/odom',
        'cmd_vel': f'/{robot.namespace}/cmd_vel',
    }
    
    ros_manager = RobotRosManager(
        robot=robot,
        namespace=robot.namespace,
        topics=topics
    )
    robot.set_ros_manager(ros_manager)
    ros_manager.start()
    ros_managers.append(ros_manager)
    
    # æ·»åŠ ç‰©ç†å›è°ƒ
    world.get_isaac_world().add_physics_callback(
        f"physics_step_robot_{i}",
        robot.on_physics_step
    )

# ä¸»å¾ªç¯
while simulation_app.is_running():
    world.tick()

# æ¸…ç†æ‰€æœ‰ ROS Manager
for ros_manager in ros_managers:
    ros_manager.stop()
```

#### 7.8 ROS é€šä¿¡ç¤ºä¾‹

**å‘å¸ƒ Odometryï¼š**
```python
# åœ¨ robot.on_physics_step() ä¸­è‡ªåŠ¨è°ƒç”¨
def publish_robot_state(self):
    """å‘å¸ƒæœºå™¨äººçŠ¶æ€åˆ° ROS"""
    if self.ros_manager:
        pos, quat = self.get_world_pose()
        vel = self.get_velocity()
        ang_vel = self.get_angular_velocity()
        
        self.ros_manager.publish_odometry(
            pos=pos,
            quat=quat,
            vel_linear=vel,
            vel_angular=ang_vel
        )
```

**é€šè¿‡ cmd_vel æ§åˆ¶ï¼š**
```bash
# æ–¹å¼ 1ï¼šç›´æ¥å‘å¸ƒè¯é¢˜
ros2 topic pub /robot_0/cmd_vel geometry_msgs/msg/Twist \
  "{linear: {x: 1.0, y: 0.0, z: 0.0}, angular: {z: 0.5}}"

# æ–¹å¼ 2ï¼šä½¿ç”¨é”®ç›˜é¥æ§
ros2 run teleop_twist_keyboard teleop_twist_keyboard \
  --ros-args --remap cmd_vel:=/robot_0/cmd_vel

# æ–¹å¼ 3ï¼šä½¿ç”¨ joystick
ros2 launch teleop_twist_joy teleop-launch.py \
  joy_config:='xbox' \
  --ros-args --remap cmd_vel:=/robot_0/cmd_vel
```

**æ‰§è¡ŒæŠ€èƒ½ï¼š**
```bash
# å¯¼èˆªåˆ°ç›®æ ‡ç‚¹
ros2 action send_goal /robot_0/skill_execution plan_msgs/action/SkillExecution \
  '{skill_request: {
    skill_list: [{
      skill: "navigate_to",
      params: [
        {key: "goal_pos", value: "[10, 20, 0]"},
        {key: "timeout", value: "30.0"}
      ]
    }]
  }}' --feedback

# è·Ÿéšè·¯å¾„
ros2 action send_goal /robot_0/skill_execution plan_msgs/action/SkillExecution \
  '{skill_request: {
    skill_list: [{
      skill: "follow_path",
      params: [
        {key: "waypoints", value: "[[0,0,0], [5,5,0], [10,0,0]]"}
      ]
    }]
  }}' --feedback
```

**ç›‘æ§çŠ¶æ€ï¼š**
```bash
# æŸ¥çœ‹ Odometry
ros2 topic echo /robot_0/odom

# æŸ¥çœ‹å¯ç”¨çš„ Action
ros2 action list

# æŸ¥çœ‹ Action ä¿¡æ¯
ros2 action info /robot_0/skill_execution

# æŸ¥çœ‹æ‰€æœ‰è¯é¢˜
ros2 topic list | grep robot_0
```

#### 7.9 è®¾è®¡ä¼˜ç‚¹

**1. å®Œå…¨è§£è€¦ï¼š**
- Robot ç±»ä¸åŒ…å«ä»»ä½• ROS ä»£ç 
- ROS Manager å¯ä»¥ç‹¬ç«‹å¯åŠ¨å’Œåœæ­¢
- ä»¿çœŸå±‚å’Œ ROS å±‚å®Œå…¨åˆ†ç¦»

**2. ç‹¬ç«‹çº¿ç¨‹ï¼š**
- ROS é€šä¿¡ä¸é˜»å¡ä»¿çœŸå¾ªç¯
- å¤šä¸ªæœºå™¨äººçš„ ROS èŠ‚ç‚¹å¹¶è¡Œè¿è¡Œ
- ä¼˜é›…çš„å¯åŠ¨å’Œå…³é—­æœºåˆ¶

**3. ç»Ÿä¸€æ¥å£ï¼š**
- æ‰€æœ‰æœºå™¨äººä½¿ç”¨ç›¸åŒçš„ ROS Manager ç»“æ„
- æ ‡å‡†çš„è¯é¢˜å‘½åè§„èŒƒï¼ˆ`/namespace/topic`ï¼‰
- ä¸€è‡´çš„ Action æ¥å£

**4. æ˜“äºæ‰©å±•ï¼š**
```python
# æ·»åŠ æ–°çš„ Publisher
def _create_publishers(self):
    # ç°æœ‰çš„ publishers
    if "odom" in self.topics:
        self.publisher_odom = self.create_publisher(...)
    
    # æ·»åŠ æ–°çš„ publisher
    if "imu" in self.topics:
        self.publisher_imu = self.create_publisher(
            Imu, self.topics["imu"], 10
        )

# æ·»åŠ æ–°çš„ Subscriber
def _create_subscribers(self):
    # ç°æœ‰çš„ subscribers
    if "cmd_vel" in self.topics:
        self.subscriber_cmd_vel = self.create_subscription(...)
    
    # æ·»åŠ æ–°çš„ subscriber
    if "goal" in self.topics:
        self.subscriber_goal = self.create_subscription(
            PoseStamped, self.topics["goal"], self.callback_goal, 10
        )
```

**5. çµæ´»çš„è¯é¢˜é…ç½®ï¼š**
```python
# æœ€å°é…ç½®
topics = {
    'odom': '/robot_0/odom',
}

# å®Œæ•´é…ç½®
topics = {
    'odom': '/robot_0/odom',
    'cmd_vel': '/robot_0/cmd_vel',
    'imu': '/robot_0/imu',
    'camera': '/robot_0/camera/image_raw',
    'lidar': '/robot_0/scan',
}
```

#### 7.10 ä¸å…¶ä»–ç³»ç»Ÿçš„é›†æˆ

**ä¸ Skill System é›†æˆï¼š**
```python
# Skill Manager é€šè¿‡ ROS Action è§¦å‘
# NodeRobot çš„ execute_callback_wrapper å¤„ç†è¯·æ±‚
def execute_callback_wrapper(self, goal_handle):
    """å¤„ç†æŠ€èƒ½æ‰§è¡Œè¯·æ±‚"""
    request = goal_handle.request.skill_request
    task_name = request.skill_list[0].skill
    params = self._parse_params(request.skill_list[0].params)
    
    # ä½¿ç”¨ Robot çš„ SkillManager
    skill_manager = self.robot_instance.skill_manager
    
    # æ‰§è¡ŒæŠ€èƒ½
    while goal_handle.is_active:
        result = skill_manager.execute_skill(task_name, **params)
        # å‘å¸ƒåé¦ˆå’Œæ£€æŸ¥å®ŒæˆçŠ¶æ€
        ...
```

**ä¸ MPC æ§åˆ¶å™¨é›†æˆï¼š**
```python
# MPC é€šè¿‡ clock å›è°ƒè‡ªåŠ¨è§¦å‘
class NodeMpcController(Node):
    def __init__(self, namespace: str, robot=None):
        self.robot = robot  # ç›´æ¥å¼•ç”¨ robot
        
        # è®¢é˜…ä»¿çœŸæ—¶é’Ÿ
        self.subscriber_sim_clock = self.create_subscription(
            Clock,
            '/isaacsim_simulation_clock',
            self.clock_callback,
            10
        )
    
    def clock_callback(self, msg: Clock):
        """æ¯æ¬¡ world.tick() åè‡ªåŠ¨è°ƒç”¨"""
        self.control_loop()
    
    def control_loop(self):
        """è®¡ç®—å¹¶ç›´æ¥è®¾ç½®é€Ÿåº¦"""
        optimal_command = self.mpc_controller.solve(...)
        
        if self.robot:
            # ç›´æ¥è®¾ç½®ï¼ˆåŒæ­¥ï¼Œæ— å»¶è¿Ÿï¼‰
            self.robot.target_linear_velocity = torch.tensor([...])
            self.robot.target_angular_velocity = torch.tensor([...])
```

#### 7.11 å¸¸è§é—®é¢˜

**é—®é¢˜ 1ï¼šROS èŠ‚ç‚¹å¯åŠ¨å¤±è´¥**
```python
# ç¡®ä¿ rclpy å·²åˆå§‹åŒ–
rclpy.init(args=None)

# ç¡®ä¿åœ¨åˆ›å»º ROS Manager ä¹‹å‰åˆ›å»ºäº† robot
robot = robot_actors[0].robot

# ç¡®ä¿è°ƒç”¨äº† start()
ros_manager.start()
```

**é—®é¢˜ 2ï¼šcmd_vel ä¸èµ·ä½œç”¨**
```python
# æ£€æŸ¥è¯é¢˜é…ç½®
topics = {
    'cmd_vel': f'/{robot.namespace}/cmd_vel',  # å¿…é¡»åŒ…å«
}

# æ£€æŸ¥è¯é¢˜æ˜¯å¦æ­£ç¡®
ros2 topic list | grep cmd_vel

# æµ‹è¯•å‘å¸ƒ
ros2 topic pub /robot_0/cmd_vel geometry_msgs/msg/Twist \
  "{linear: {x: 1.0}}" --once
```

**é—®é¢˜ 3ï¼šå¤šæœºå™¨äººå‘½åå†²çª**
```python
# ç¡®ä¿æ¯ä¸ªæœºå™¨äººæœ‰å”¯ä¸€çš„ namespace
for i, robot in enumerate(robots):
    ros_manager = RobotRosManager(
        robot=robot,
        namespace=f'robot_{i}',  # å”¯ä¸€çš„å‘½åç©ºé—´
        topics={
            'odom': f'/robot_{i}/odom',
            'cmd_vel': f'/robot_{i}/cmd_vel',
        }
    )
```

***



### 4. æ§åˆ¶æµç¨‹ï¼ˆè§£è€¦è®¾è®¡ï¼‰

**Robot å±‚ï¼ˆon_physics_stepï¼‰ï¼š**
```python
def on_physics_step(self, step_size):
    # 1. ä» Isaac Sim è¯»å–çŠ¶æ€ï¼Œæ›´æ–° _position, _quat, _linear_velocity, _angular_velocity
    self.publish_robot_state()
    
    # 2. æ›´æ–°ç›¸æœºè§†é‡
    self._update_camera_view()
    
    # 3. å°† target_linear_velocity, target_angular_velocity åº”ç”¨åˆ° Isaac Sim
    # Note: target_linear_velocity ç”± MPC (Application å±‚) é€šè¿‡ clock å›è°ƒè®¾ç½®
    self.controller_simplified()
```

**Application å±‚ï¼ˆMPC è‡ªåŠ¨è§¦å‘ï¼‰ï¼š**

```python
# application/skills/base/navigation/node_controller_mpc.py
def clock_callback(self, msg: Clock):
    """è®¢é˜… /isaacsim_simulation_clockï¼Œæ¯æ¬¡ world.tick() åè‡ªåŠ¨è°ƒç”¨"""
    self.latest_sim_time = msg.clock.sec + msg.clock.nanosec / 1e9

    # è‡ªåŠ¨è°ƒç”¨ control_loopï¼ˆApplication å±‚æ§åˆ¶ï¼‰
    self.control_loop()


def control_loop(self):
    """MPC è®¡ç®—å¹¶ç›´æ¥è®¾ç½® robot.target_linear_velocity"""
    optimal_command = self.mpc_controller.solve(...)

    if self.robot:
        self.robot.target_linear_velocity = torch.tensor([...])
        self.robot.target_angular_velocity = torch.tensor([...])
```

**å®Œå…¨è§£è€¦çš„è®¾è®¡ï¼š**
- âœ… Robot å±‚ä¸çŸ¥é“ MPC çš„å­˜åœ¨
- âœ… MPC é€šè¿‡ ROS clock è‡ªåŠ¨è§¦å‘
- âœ… MPC ç›´æ¥è®¾ç½® `target_velocity`ï¼ˆåŒæ­¥ï¼Œæ— å»¶è¿Ÿï¼‰
- âœ… Robot åªè´Ÿè´£åº”ç”¨å‘½ä»¤åˆ° Isaac Sim

---

### 5. MPC æ§åˆ¶å™¨ - åŒæ­¥æ§åˆ¶

**é—®é¢˜ï¼šROS å¼‚æ­¥å»¶è¿Ÿ**
```python
# é”™è¯¯æ–¹å¼ï¼šé€šè¿‡ ROS topicï¼ˆå¼‚æ­¥ï¼Œæœ‰å»¶è¿Ÿï¼‰
def control_loop(self):
    optimal_command = self.mpc_controller.solve(...)
    
    # å‘å¸ƒåˆ° ROS topic
    cmd_msg = Twist()
    cmd_msg.linear.x = optimal_command[0]
    self.cmd_vel_pub.publish(cmd_msg)
    
    # ROS bridge åœ¨å¦ä¸€ä¸ªçº¿ç¨‹ä¸­æ¥æ”¶ï¼Œæœ‰å»¶è¿Ÿï¼
    # å½“å‰å¸§çš„ controller_simplified() ä¼šä½¿ç”¨æ—§é€Ÿåº¦
```

**è§£å†³æ–¹æ¡ˆï¼šç›´æ¥è®¾ç½®ï¼ˆåŒæ­¥ï¼Œæ— å»¶è¿Ÿï¼‰**

```python
class NodeMpcController(Node):
    def __init__(self, namespace: str, robot=None):
        self.robot = robot  # ç›´æ¥å¼•ç”¨ robot

    def control_loop(self):
        optimal_command = self.mpc_controller.solve(...)

        # ç›´æ¥è®¾ç½®ç›®æ ‡é€Ÿåº¦ï¼ˆåŒæ­¥ï¼Œæ— å»¶è¿Ÿï¼‰
        if self.robot:
            self.robot.target_linear_velocity = torch.tensor([
                optimal_command[0],
                optimal_command[1],
                optimal_command[2]
            ])
            self.robot.target_angular_velocity = torch.tensor([
                0.0, 0.0, optimal_command[3]
            ])

        # ä»ç„¶å‘å¸ƒåˆ° ROSï¼ˆç”¨äºç›‘æ§/è°ƒè¯•ï¼‰
        self.cmd_vel_pub.publish(cmd_msg)
```

**åˆ›å»ºæ—¶ä¼ é€’ robot å¼•ç”¨ï¼š**
```python
# ros/ros_manager_robot.py
self.node_controller_mpc = NodeMpcController(
    namespace=self.namespace, 
    robot=self.robot  # ä¼ é€’ robot å¼•ç”¨
)
```

---

---

### 8. åˆ†å±‚è¾¹ç•Œ - Application å±‚ä¸è°ƒç”¨ Isaac Sim API

**é—®é¢˜ï¼š**
```python
# é”™è¯¯ï¼šApplication å±‚ç›´æ¥è°ƒç”¨ Isaac Sim API
pos, quat = robot.body.get_world_pose()  # æ¸²æŸ“æœŸé—´ä¼šæŠ¥é”™ï¼
```

**è§£å†³æ–¹æ¡ˆï¼š**
```python
# robot/robot.py
class Robot:
    def __init__(self):
        self._body: BodyRobot = None  # ç§æœ‰ï¼Œä»…å†…éƒ¨ä½¿ç”¨
    
    # å…¬å…±æ¥å£ï¼ˆApplication å±‚ä½¿ç”¨ï¼‰
    def get_world_pose(self):
        """è¿”å›ç¼“å­˜çš„çŠ¶æ€ï¼Œä¸è°ƒç”¨ Isaac Sim API"""
        return self.position, self.quat
    
    def get_velocity(self):
        """è¿”å›ç¼“å­˜çš„å®é™…é€Ÿåº¦"""
        return self._velocity
    
    def get_config(self):
        """è¿”å›é…ç½®"""
        return self._body.cfg_robot
    
    # å‘åå…¼å®¹ï¼ˆå¸¦è­¦å‘Šï¼‰
    @property
    def body(self):
        warnings.warn("Direct access to robot.body is deprecated", DeprecationWarning)
        return self._body
```

**Application å±‚ä½¿ç”¨ï¼š**
```python
# application/skills/base/navigation/navigate_to.py
def navigate_to(robot, goal_pos, **kwargs):
    # æ­£ç¡®ï¼šä½¿ç”¨å…¬å…±æ¥å£
    start_pos, start_quat = robot.get_world_pose()
    
    # é”™è¯¯ï¼šä¸è¦ç›´æ¥è®¿é—® body
    # start_pos, start_quat = robot.body.get_world_pose()
```

---

## ğŸ® æ§åˆ¶æ–¹å¼

### 1. Python APIï¼ˆç›´æ¥æ§åˆ¶ï¼‰
```python
from simulation import RobotControl

control = RobotControl()
control.linear_velocity = [1.0, 0.0, 0.0]
control.angular_velocity = [0.0, 0.0, 0.5]
robot.apply_control(control)
```

### 2. ROS Topicï¼ˆé€Ÿåº¦æ§åˆ¶ï¼‰
```bash
ros2 topic pub /robot_0/cmd_vel geometry_msgs/msg/Twist \
  "{linear: {x: 1.0, y: 0.0, z: 0.0}, angular: {z: 0.5}}"
```

### 3. ROS Actionï¼ˆæŠ€èƒ½ç³»ç»Ÿï¼‰
```bash
ros2 action send_goal /robot_0/skill_execution plan_msgs/action/SkillExecution \
  '{skill_request: {skill_list: [{skill: "navigate_to", params: [{key: "goal_pos", value: "[10, 20, 0]"}]}]}}' --feedback
```

### 4. MPC æ§åˆ¶ï¼ˆè‡ªåŠ¨ï¼‰
```python
# MPC åœ¨ on_physics_step ä¸­è‡ªåŠ¨è¿è¡Œ
# ç›´æ¥è®¾ç½® robot.target_linear_velocity
# æ— éœ€æ‰‹åŠ¨å¹²é¢„
```

---

## ğŸ“ æ–‡ä»¶ç»“æ„

```
simulation/                          # ä»¿çœŸå±‚ï¼ˆCARLA é£æ ¼ï¼‰
â”œâ”€â”€ __init__.py                     # å¯¼å‡ºå…¬å…±ç±»
â”œâ”€â”€ server.py                       # Server ç±»
â”œâ”€â”€ world.py                        # World ç±»
â”‚   â”œâ”€â”€ spawn_actor()              # ç»Ÿä¸€åˆ›å»ºæ¥å£
â”‚   â”œâ”€â”€ _spawn_robot()             # åˆ›å»ºæœºå™¨äºº
â”‚   â”œâ”€â”€ _spawn_static_prop()       # åˆ›å»ºé™æ€ç‰©ä½“
â”‚   â””â”€â”€ load_actors_from_config()  # ä»é…ç½®åŠ è½½
â”œâ”€â”€ actor.py                        # Actor åŸºç±»
â”œâ”€â”€ robot_actor.py                  # RobotActor ç±»
â”œâ”€â”€ static_actor.py                 # StaticActor ç±»ï¼ˆæ–°å¢ï¼‰
â”œâ”€â”€ transform.py                    # Transform æ•°æ®ç±»
â”œâ”€â”€ blueprint.py                    # Blueprint ç³»ç»Ÿ
â””â”€â”€ control.py                      # RobotControl ç±»

robot/
â”œâ”€â”€ robot.py                        # Robot åŸºç±»
â”‚   â”œâ”€â”€ çŠ¶æ€å˜é‡ï¼ˆç§æœ‰ï¼‰
â”‚   â”‚   â”œâ”€â”€ position, quat
â”‚   â”‚   â”œâ”€â”€ _velocity
â”‚   â”‚   â””â”€â”€ _angular_velocity
â”‚   â”œâ”€â”€ å‘½ä»¤å˜é‡ï¼ˆå…¬å…±ï¼‰
â”‚   â”‚   â”œâ”€â”€ target_velocity
â”‚   â”‚   â””â”€â”€ target_angular_velocity
â”‚   â”œâ”€â”€ å…¬å…±æ¥å£
â”‚   â”‚   â”œâ”€â”€ get_world_pose()
â”‚   â”‚   â”œâ”€â”€ get_velocity()
â”‚   â”‚   â”œâ”€â”€ get_angular_velocity()
â”‚   â”‚   â”œâ”€â”€ set_target_velocity()
â”‚   â”‚   â””â”€â”€ apply_control()
â”‚   â””â”€â”€ å†…éƒ¨æ–¹æ³•
â”‚       â”œâ”€â”€ publish_robot_state()
â”‚       â”œâ”€â”€ controller_simplified()
â”‚       â””â”€â”€ on_physics_step()
â””â”€â”€ body/                           # Body å®ç°ï¼ˆIsaac Sim å±‚ï¼‰
    â”œâ”€â”€ body_robot.py
    â”œâ”€â”€ body_jetbot.py
    â””â”€â”€ ...

application/
â”œâ”€â”€ skill_manager.py                # æŠ€èƒ½ç®¡ç†å™¨
â””â”€â”€ skills/                         # æŠ€èƒ½å®ç°
    â”œâ”€â”€ base/navigation/
    â”‚   â”œâ”€â”€ navigate_to.py
    â”‚   â””â”€â”€ node_controller_mpc.py  # MPC æ§åˆ¶å™¨
    â””â”€â”€ ...

ros/
â”œâ”€â”€ robot_ros_manager.py            # ROS ç®¡ç†å™¨
â”‚   â”œâ”€â”€ ç®¡ç† NodeRobot å’Œå¯¼èˆªèŠ‚ç‚¹
â”‚   â”œâ”€â”€ ç®¡ç† executor å’Œçº¿ç¨‹
â”‚   â””â”€â”€ åˆ›å»º NodeMpcController(robot=robot)
â””â”€â”€ node_robot.py                   # ROS Nodeï¼ˆåŒ…å« cmd_vel æ”¯æŒï¼‰
    â”œâ”€â”€ Publishers: odom
    â”œâ”€â”€ Subscribers: sim_clock, cmd_vel
    â”œâ”€â”€ Action Servers: skill_execution
    â””â”€â”€ Action Clients: path_planner
```

---

## ğŸ”„ å®Œæ•´æ•°æ®æµ

### å¯¼èˆªæ§åˆ¶æµç¨‹ï¼ˆnavigate_to skillï¼‰

```
1. ç”¨æˆ·å‘èµ·å¯¼èˆªè¯·æ±‚
   ROS Action: /robot_0/skill_execution
   â†“
2. Skill æ‰§è¡Œ
   navigate_to() å‘é€è·¯å¾„è§„åˆ’è¯·æ±‚
   â†“
3. è·¯å¾„è§„åˆ’ï¼ˆROSï¼‰
   NodePlannerOmpl è®¡ç®—è·¯å¾„
   â†“
4. è½¨è¿¹ç”Ÿæˆï¼ˆROSï¼‰
   NodeTrajectoryGenerator ç”Ÿæˆå¸¦æ—¶é—´æˆ³çš„è½¨è¿¹
   â†“
5. ä»¿çœŸå¾ªç¯ï¼ˆæ¯å¸§ï¼‰
   world.tick()
   â”œâ”€ Isaac Sim æ­¥è¿›
   â”œâ”€ å‘å¸ƒ /isaacsim_simulation_clock
   â”‚
   â”œâ”€ [Application å±‚] MPC.clock_callback() è‡ªåŠ¨è§¦å‘
   â”‚  â””â”€ control_loop()
   â”‚     â””â”€ robot.target_velocity = ...  # ç›´æ¥è®¾ç½®å‘½ä»¤
   â”‚
   â””â”€ [Robot å±‚] robot.on_physics_step()
      â”œâ”€ publish_robot_state()           # æ›´æ–°çŠ¶æ€
      â””â”€ controller_simplified()         # åº”ç”¨å‘½ä»¤åˆ° Isaac Sim
         â””â”€ _body.set_linear_velocities(target_velocity)
   â†“
6. çŠ¶æ€åé¦ˆ
   publish_robot_state() è¯»å–æ–°ä½ç½®
   å‘å¸ƒ odom åˆ° ROS
   MPC ä½¿ç”¨æ–°ä½ç½®è®¡ç®—ä¸‹ä¸€æ­¥
```

### å…³é”®ç‚¹

1. **å®Œå…¨è§£è€¦**ï¼šRobot å±‚ä¸è°ƒç”¨ MPCï¼ŒMPC é€šè¿‡ clock è‡ªåŠ¨è§¦å‘
2. **MPC ç›´æ¥è®¾ç½®é€Ÿåº¦**ï¼š`robot.target_velocity = ...`ï¼ˆåŒæ­¥ï¼Œæ— å»¶è¿Ÿï¼‰
3. **çŠ¶æ€ä¸è¦†ç›–å‘½ä»¤**ï¼š`publish_robot_state()` åªæ›´æ–° `_velocity`ï¼Œä¸æ›´æ–° `target_velocity`
4. **å‘½ä»¤åº”ç”¨åˆ° Isaac Sim**ï¼š`controller_simplified()` ä½¿ç”¨ `target_velocity`
5. **åˆ†å±‚æ¸…æ™°**ï¼šApplication å±‚è®¡ç®—å‘½ä»¤ï¼ŒRobot å±‚æ‰§è¡Œå‘½ä»¤

---

## ğŸ¯ æ ‡å‡†ä½¿ç”¨æµç¨‹

```python
# 1. åˆå§‹åŒ–
import rclpy
from containers import get_container, reset_container

rclpy.init(args=None)
reset_container()
container = get_container()
world = container.world_configured()

# 2. åŠ è½½æœºå™¨äººï¼ˆè¿”å› Actor åˆ—è¡¨ï¼‰
robot_actors = world.load_actors_from_config("config/robot_swarm_cfg.yaml")
robots = [actor.robot for actor in robot_actors]  # æå– Robot å¯¹è±¡

# 3. åˆ›å»ºé™æ€ç‰©ä½“
blueprint_library = world.get_blueprint_library()

car_bp = blueprint_library.find('static.prop.car')
car_bp.set_attribute('name', 'car0')
car_bp.set_attribute('scale', [2, 5, 1.0])
car_actor = world.spawn_actor(car_bp, Transform(location=Location(10, 5, 0)))

# 4. è®¾ç½® ROSï¼ˆæ¯ä¸ªæœºå™¨äººï¼‰
from ros.ros_manager_robot import RobotRosManager

for robot in robots:
    ros_manager = RobotRosManager(
        robot=robot,
        namespace=robot.namespace,
        topics=robot.get_topics()  # ä½¿ç”¨å…¬å…±æ¥å£
    )
    robot.set_ros_manager(ros_manager)
    ros_manager.start()

# 5. åˆå§‹åŒ–
world.reset()
world.initialize_robots()

# 6. æ·»åŠ ç‰©ç†å›è°ƒ
for i, robot in enumerate(robots):
    world.get_isaac_world().add_physics_callback(
        f"physics_step_robot_{i}",
        robot.on_physics_step
    )

# 7. cmd_vel æ”¯æŒï¼ˆå·²é›†æˆåˆ° NodeRobotï¼‰
# Note: cmd_vel subscriber å·²ç»é›†æˆåˆ° NodeRobot ä¸­
# ä¸éœ€è¦é¢å¤–çš„ RosControlBridge
# åªéœ€ç¡®ä¿ topics é…ç½®ä¸­åŒ…å« cmd_velï¼š
# topics = {
#     "odom": f"/{namespace}/odom",
#     "cmd_vel": f"/{namespace}/cmd_vel",
# }

# 8. Skill System
from application import SkillManager

for robot in robots:
    skill_manager = SkillManager(robot, auto_register=True)
    robot.skill_manager = skill_manager

# 9. ä¸»å¾ªç¯
while simulation_app.is_running():
    world.tick()

# 10. æ¸…ç†
rclpy.shutdown()
```

---

## ğŸŒŸ å…³é”®æ”¹è¿›æ€»ç»“

### 1. Actor ç³»ç»Ÿç»Ÿä¸€
- âœ… `spawn_actor()` ç»Ÿä¸€è¿”å› Actor å¯¹è±¡
- âœ… RobotActor å’Œ StaticActor ç»§æ‰¿è‡ª Actor åŸºç±»
- âœ… ä½¿ç”¨ Blueprint tags åˆ¤æ–­ç±»å‹ï¼Œè€Œä¸æ˜¯ `robot_class is None`

### 2. çŠ¶æ€ä¸å‘½ä»¤åˆ†ç¦»ï¼ˆCARLA é£æ ¼ï¼‰
- âœ… çŠ¶æ€å˜é‡ï¼š`_velocity`, `_angular_velocity`ï¼ˆå®é™…å€¼ï¼Œåªè¯»ï¼‰
- âœ… å‘½ä»¤å˜é‡ï¼š`target_velocity`, `target_angular_velocity`ï¼ˆç›®æ ‡å€¼ï¼Œå¯å†™ï¼‰
- âœ… `publish_robot_state()` åªæ›´æ–°çŠ¶æ€ï¼Œä¸è¦†ç›–å‘½ä»¤

### 3. åŒæ­¥æ§åˆ¶ï¼ˆé¿å… ROS å»¶è¿Ÿï¼‰
- âœ… MPC ç›´æ¥è®¾ç½® `robot.target_velocity`
- âœ… ä¸ä¾èµ– ROS topic çš„å¼‚æ­¥å›è°ƒ
- âœ… åœ¨åŒä¸€ä¸ª physics step å†…å®Œæˆï¼šè®¡ç®— â†’ è®¾ç½® â†’ åº”ç”¨

### 4. åˆ†å±‚è¾¹ç•Œæ¸…æ™°
- âœ… `robot._body` ç§æœ‰ï¼ŒApplication å±‚ä¸å¯è®¿é—®
- âœ… å…¬å…±æ¥å£ï¼š`get_world_pose()`, `get_velocity()` ç­‰
- âœ… è¿”å›ç¼“å­˜å€¼ï¼Œä¸åœ¨ Application å±‚è°ƒç”¨ Isaac Sim API

### 5. MPC å®Œå…¨è§£è€¦ï¼ˆæ–°å¢ï¼‰
- âœ… MPC é€šè¿‡è®¢é˜… `/isaacsim_simulation_clock` è‡ªåŠ¨è§¦å‘
- âœ… Robot å±‚ä¸è°ƒç”¨ MPCï¼Œä¿æŒåˆ†å±‚ç‹¬ç«‹
- âœ… Application å±‚æ§åˆ¶å™¨è‡ªä¸»è¿è¡Œ

### 6. å‘½åçº¦å®šï¼ˆCARLA é£æ ¼ï¼‰
- âœ… `get_velocity()` - è·å–å®é™…é€Ÿåº¦ï¼ˆçŠ¶æ€ï¼‰
- âœ… `target_velocity` - ç›®æ ‡é€Ÿåº¦ï¼ˆå‘½ä»¤ï¼‰
- âœ… `apply_control(control)` - åº”ç”¨æ§åˆ¶
- âœ… ç¬¦åˆ CARLA å’Œ ROS çš„é€šç”¨çº¦å®š

---

## ğŸ› å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

### é—®é¢˜ 1ï¼šæœºå™¨äººä¸åŠ¨ï¼ˆMPC å‘å¸ƒé€Ÿåº¦ä½†æœºå™¨äººé€Ÿåº¦ä¸º 0ï¼‰

**åŸå› ï¼š**
`publish_robot_state()` ä» Isaac Sim è¯»å–å½“å‰é€Ÿåº¦ï¼ˆ0ï¼‰ï¼Œè¦†ç›–äº† MPC è®¾ç½®çš„ `target_velocity`ã€‚

**è§£å†³æ–¹æ¡ˆï¼š**
- åŒºåˆ†çŠ¶æ€å˜é‡ï¼ˆ`_velocity`ï¼‰å’Œå‘½ä»¤å˜é‡ï¼ˆ`target_velocity`ï¼‰
- `publish_robot_state()` åªæ›´æ–°çŠ¶æ€ï¼Œä¸æ›´æ–°å‘½ä»¤
- MPC ç›´æ¥è®¾ç½® `target_velocity`ï¼Œä¸é€šè¿‡ ROS topic

### é—®é¢˜ 2ï¼šApplication å±‚è°ƒç”¨ Isaac Sim API å¯¼è‡´æ¸²æŸ“é”™è¯¯

**åŸå› ï¼š**
Application å±‚ç›´æ¥è®¿é—® `robot.body.get_world_pose()`ï¼Œåœ¨æ¸²æŸ“æœŸé—´è°ƒç”¨ä¼šæŠ¥é”™ã€‚

**è§£å†³æ–¹æ¡ˆï¼š**
- å°† `body` æ”¹ä¸º `_body`ï¼ˆç§æœ‰ï¼‰
- æä¾›å…¬å…±æ¥å£ï¼š`get_world_pose()`, `get_velocity()` ç­‰
- è¿”å›ç¼“å­˜çš„çŠ¶æ€å€¼ï¼Œä¸ç›´æ¥è°ƒç”¨ Isaac Sim API

### é—®é¢˜ 3ï¼šspawn_actor è¿”å›ç±»å‹ä¸ä¸€è‡´

**åŸå› ï¼š**
é™æ€ç‰©ä½“è¿”å› `prim_path`ï¼ˆå­—ç¬¦ä¸²ï¼‰ï¼Œæœºå™¨äººè¿”å› `robot` å¯¹è±¡ã€‚

**è§£å†³æ–¹æ¡ˆï¼š**
- åˆ›å»º `StaticActor` ç±»åŒ…è£…é™æ€ç‰©ä½“
- `spawn_actor()` ç»Ÿä¸€è¿”å› Actor å¯¹è±¡
- ä½¿ç”¨ Blueprint tags åˆ¤æ–­ç±»å‹

### é—®é¢˜ 4ï¼šMPC é€Ÿåº¦å‘½ä»¤å»¶è¿Ÿä¸€å¸§

**åŸå› ï¼š**
MPC é€šè¿‡ ROS topic å‘å¸ƒé€Ÿåº¦ï¼ŒROS bridge åœ¨å¦ä¸€ä¸ªçº¿ç¨‹å¼‚æ­¥æ¥æ”¶ï¼Œæœ‰å»¶è¿Ÿã€‚

**è§£å†³æ–¹æ¡ˆï¼š**
- MPC ç›´æ¥è®¾ç½® `robot.target_velocity`ï¼ˆåŒæ­¥ï¼‰
- ä»ç„¶å‘å¸ƒåˆ° ROS topicï¼ˆç”¨äºç›‘æ§ï¼‰
- åœ¨ `on_physics_step` ä¸­æŒ‰æ­£ç¡®é¡ºåºæ‰§è¡Œ

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- `VELOCITY_NAMING_CONVENTION.md` - é€Ÿåº¦å‘½åçº¦å®šï¼ˆCARLA é£æ ¼ï¼‰
- `CARLA_VELOCITY_NAMING_RESEARCH.md` - CARLA å‘½åç ”ç©¶
- `ARCHITECTURE_FIX_SUMMARY.md` - æ¶æ„ä¿®å¤æ€»ç»“
- `docs/ROS_DECOUPLING_FINAL_SUMMARY.md` - ROS è§£è€¦æ€»ç»“
- `docs/WORLD_API_COMPARISON.md` - World API å¯¹æ¯”
- `application/skills/README.md` - æŠ€èƒ½å¼€å‘æŒ‡å—

## ğŸš€ åç»­å·¥ä½œ

### çŸ­æœŸ
- [ ] å®Œå–„æ‰€æœ‰æŠ€èƒ½çš„å®ç°
- [ ] æ·»åŠ æ›´å¤šé™æ€ç‰©ä½“ç±»å‹
- [ ] ä¼˜åŒ–æ€§èƒ½å’Œç¨³å®šæ€§

### ä¸­æœŸ
- [ ] ç»Ÿä¸€çš„ä¼ æ„Ÿå™¨æ¥å£ï¼ˆå‚è€ƒ CARLAï¼‰
- [ ] Vehicle ç±»å‹æ”¯æŒï¼ˆå¸¦ç‰©ç†æ§åˆ¶ï¼‰
- [ ] ç¢°æ’æ£€æµ‹å’Œç‰©ç†äº‹ä»¶

### é•¿æœŸ
- [ ] Actor ç”Ÿå‘½å‘¨æœŸç®¡ç†
- [ ] å½•åˆ¶å’Œå›æ”¾
- [ ] å¤šæœºå™¨äººååŒæ¡†æ¶
- [ ] å®Œæ•´çš„ CARLA API å…¼å®¹å±‚

---

**æœ€åæ›´æ–°ï¼š** 2024å¹´ï¼ˆåŸºäºæœ€æ–°æ¶æ„æ”¹è¿›ï¼‰
